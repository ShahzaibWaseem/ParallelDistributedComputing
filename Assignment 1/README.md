Assignment 1 \[100 Points\]
---------------------------

In this assignment, we will learn how to parallelize simple programs using C++11 threads. There are two problems in this assignment, and for each problem you are provided the serial C++ implementation, the expected parallelization strategy, and the expected output to be generated by your parallel solution.

Before starting this assignment, you should have completed [Tutorial 1](https://www.cs.sfu.ca/~keval/teaching/cmpt770/fall21/slurm_tutorial/release/index.html) which walks you through how to use our servers for your code development.

### General Instructions

1.  You are provided with the serial version of all the programs [here](https://www.cs.sfu.ca/~keval/teaching/cmpt770/fall21/assignments/assignment1/assignment1.tar.gz). To run a program (e.g., `pi_calculation.cpp`), follow the steps below:
    *   Run `make pi_calculation`. This creates a binary file called `pi_calculation`.
    *   Create a slurm job to run the binary file using the following command: `./pi_calculation --nPoints 12345678`
    *   Use the command-line argument `--nPoints` to specify the number of points to be generated (detailed description about `pi_calculation` mentioned below).
2.  All parallel programs should have the command-line argument `--nWorkers` to specify the number of threads for the program. Example: `--nWorkers 4`.
3.  **While testing your solutions, make sure that `cpus-per-task` is correctly specified in your slurm config file based on your requirement.**
4.  You will be asked to print the time spent by different threads on specific code regions. The time spent by any code region can be computed as follows:
    
        timer t1;
        t1.start();
        /* ---- Code region whose time is to be measured --- */
        double time_taken = t1.stop();
        
    
5.  Sample outputs for all the programs can be found in `sample_outputs` directory. **Programs will be evaluated and graded automatically. Please make sure that your program output strictly follows the sample output format.**
6.  We have provided test scripts for you to quickly test your solutions during your development process. You can test your code using the test script available at `/scratch/assignment1/test_scripts/`. Note that these test scripts only validate the output formats, and a different evaluation script will be used for grading the assignments. **Important: You should use slurm when performing these and other tests**. The test scripts under `/scratch/assignment1/test_scripts/` folder test for up to 4 threads; make sure `--cpus-per-task=4` is set in your slurm job.
    
        $ ls /scratch/assignment1/test_scripts/*tester.pyc
        pi_calculation_tester.pyc triangle_counting_tester.pyc
        
    
7.  Certain programs operate on graph datasets. Sample input graphs are available at `/scratch/input_graphs/` on the compute nodes (note they are present on the compute nodes only, and hence you can access them via slurm only).
    
        $ ls /scratch/input_graphs/*.cs*
        lj.csc  lj.csr  roadNet-CA.csc  roadNet-CA.csr  test_25M_50M.csc  test_25M_50M.csr
        
    
    If you are interested in checking out the original graph datasets (this is not required to solve the assignment), you can find them [here](https://snap.stanford.edu/data/index.html).
8.  If you'd like to test your solution with more graph datasets, you can create your own simple graphs as follows:
    *   Create a file called `testGraph.txt` with the list of edges (one edge on each line in "`<source> <destination>`" form) in the graph. For example,
        
            1 2
            2 3
            
        
    *   Run `/scratch/input_graphs/SNAPtoBinary testGraph.txt testGraphConverted`. This will create `testGraphConverted.csr` and `testGraphConverted.csc` files which are [CSR and CSC](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)) representations of the graph.
    *   To use the graphs in your solutions, use the command line argument `--inputFile "testGraphConverted"`.

### 1\. Monte Carlo Pi Estimation \[50 Points\]

The value of Pi (`3.14159`) can be estimated using Monte Carlo method as described below:

1.  Consider a circle of radius `0.5` units that is inscribed in a unit square (each side is `1` unit).
2.  The ratio of their areas is: `pi * r * r / 2r * 2r = pi / 4`.
3.  We randomly generate `n` points inside the square. Let `c` out of the `n` points fall inside the circle.
4.  Pi is then approximated as: `pi / 4 = c / n` `==>` `pi = 4 * c / n`.

The program below implements the above algorithm.

        uint circle_count = 0;
        double x_coord, y_coord;
        for (uint i = 0; i < n; i++) {
            x_coord = (2.0 * get_random_coordinate(&random_seed)) - 1.0;
            y_coord = (2.0 * get_random_coordinate(&random_seed)) - 1.0;
            if ((sqr(x_coord) + sqr(y_coord)) <= 1.0)
                circle_count++;
        }
        double pi_value = 4.0 * (double)circle_points / (double)n;
    

Our goal is to parallelize the above algorithm. Specifically, we are interested in parallelizing the for loop such that each thread generates (approximately) `n/T` points, where `T` is the number of threads. Below is the pseudo-code showing the logic of our parallel solution:

        Create T threads
        for each thread in parallel {
            Get the circle_count for (approximately) n/T points
        }
        total_circle_points = Accumulate the circle_counts from all threads
        pi_value = 4.0 * total_circle_points / n;
    

The serial implementation is available in `pi_calculation.cpp`. You have to parallelize the given serial implementation using C++11 threads.

Your parallel solution must satisfy the following:

1.  The file should be named `pi_calculation_parallel.cpp`.
2.  Your parallel solution must output the following information:
    *   Total number of threads used.
    *   For each thread: the number of random points generated, the number of points within the circle, and the time taken to generate and process these points (your threads should be numbered between `[0, T)`).
    *   The total number of points generated.
    *   The total number of points within the circle.
    *   The total time taken for the entire execution (the code region to be timed is highlighted using comments in the serial code).
3.  The sample output can be found in `sample_outputs/pi_calculation.output`.

Please note that the output format should strictly match the expected format (including "spaces" and "commas"). You can test your code using the test script as follows:

        $ python /scratch/assignment1/test_scripts/pi_calculation_tester.pyc --execPath=<absolute path of pi_calculation_parallel>
    

### 2\. Triangle Counting \[50 Points\]

The number of triangles in a [graph](https://en.wikipedia.org/wiki/Graph_(abstract_data_type)) can be computed by counting the number of triangles formed by each edge in the graph. For an edge `(u, v)`, the number of triangles it forms is given by: `|A` `∩` `B|` where `A` is the set of inNeighbors of `u` excluding `v`, and `B` is the set of outNeighbors of `v` excluding `u`.

The program below counts the number of triangles in a given graph (`count_triangles_between(u, v)` computes the above formula).

        triangle_count = 0
        for u in Graph.all_vertices {
            for v in u.outNeighbors() {
                triangle_count += count_triangles_between(u, v)
            }
        }
        triangle_count = triangle_count / 3 // divide by 3 to get the number of unique triangles
    

Our goal is to parallelize the above algorithm such that each thread works on a sub-graph. Below is the pseudo-code showing the logic of our parallel solution:

        Create T threads
        for each thread in parallel {
            Compute the number of triangles created by the vertices allocated to the thread        
        }
        triangle_count = Accumulate the triangle counts from all the threads
        triangle_count = triangle_count / 3
    

The serial implementation is available in `triangle_counting.cpp`. You have to parallelize the given serial implementation using C++11 threads.

1.  The file should be named `triangle_counting_parallel.cpp`. The input graph file should be specified using the command-line parameter `--inputFile` (similar to the serial code).
2.  Your parallel solution must output the following information:
    *   Total number of threads used.
    *   For each thread: the number of triangles counted and the time taken to count the triangles (your threads should be numbered between `[0, T)`).
    *   The total number of triangles in the graph.
    *   The total number of unique triangles in the graph.
    *   The total time taken for the entire execution (the code region to be timed is highlighted using comments in the serial code).
3.  The sample console output can be found in `sample_outputs/pi_calculation.output`.

Please note that the output format should strictly match the expected format (including "spaces" and "commas"). You can test your code using the test script as follows:

        $ python /scratch/assignment1/test_scripts/triangle_counting_tester.pyc --execPath=<absolute path of triangle_counting_parallel>
    

### Submission Guidelines

*   Make sure that your solutions folder has the following files and sub-folders. Let's say your solutions folder is called `my_assignment1_solutions`. It should contain:
    
    *   `core/` -- The folder containing all core files. It is already available in the assignement package. Do not modify it or remove any files.
    *   `Makefile` -- Makefile for the project. This file should not be changed.
    *   `pi_calculation_parallel.cpp`
    *   `triangle_counting_parallel.cpp`
*   To create the submission file, follow the steps below:
    
    1.  Enter in your solutions folder, and remove all the object/temporary files.
        
            $ cd my_assignment1_solutions/
            $ make clean
            
        
    2.  Create the tar.gz file.
        
            $ tar cvzf assignment1.tar.gz *
            
        
        which creates a compressed tar ball that contains the contents of the folder.
    3.  Validate the tar ball using the `submission_validator.pyc` script.
        
            $ python /scratch/assignment1/test_scripts/submission_validator.pyc --tarPath=assignment1.tar.gz
            
        
*   Submit via [CourSys](https://courses.cs.sfu.ca/) by the deadline posted there.
    

* * *

Copyright © 2020 Keval Vora. All rights reserved.